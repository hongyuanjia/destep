# OCCUPANT_GAINS -> People & DesignSpecification:OutdoorAir
destep_conv_people <- function(dest, ep) {
    DBI::dbGetQuery(dest, "SELECT * FROM OCCUPANT_GAINS", n = 5)
    DBI::dbListFields(dest, "SCHEDULE_YEAR")
    DBI::dbListFields(dest, "DIST_MODE")

    # NOTE: In DeST, the dehumidification load is calculated by the humidity
    # generated by people multiplied by the latent heat of vaporization (2500
    # kJ/kg, a fixed value). While in EnergyPlus, the total heat generated from
    # people is input and latent heat is calculated by a polynomial function or
    # the value of `Sensible Heat Fraction`.
    people <- DBI::dbGetQuery(
        dest,
        n = 5,
        "
        SELECT
        O.GAIN_ID        AS ID,
        O.NAME           AS NAME,
        R.NAME           AS ROOM_NAME,
        S.SCHEDULE_ID    AS SCHEDULE_ID,
        S.NAME           AS SCHEDULE_NAME,
        -- check if the people is calculated by area or by number
        CASE
            WHEN O.PER_AREA = 1 THEN 'People/Area'
            ELSE 'People'
        END              AS METHOD,
        CASE
            WHEN O.PER_AREA != 1 THEN O.MAXNUMBER
            ELSE NULL
        END              AS MAX_NUMBER_OF_PEOPLE,
        CASE
            WHEN O.PER_AREA == 1 THEN O.MAXNUMBER
            ELSE NULL
        END              AS MAX_PEOPLE_PER_AREA,
        CASE
            WHEN O.PER_AREA != 1 THEN O.MINNUMBER
            ELSE NULL
        END              AS MIN_NUMBER_OF_PEOPLE,
        CASE
            WHEN O.PER_AREA == 1 THEN O.MINNUMBER
            ELSE NULL
        END              AS MIN_PEOPLE_PER_AREA,
        HEAT_PER_PERSON + ROUND(DAMP_PER_PERSON * 2500 / 3.6, 2) AS HEAT_PER_PERSON,
        ROUND(HEAT_PER_PERSON / (HEAT_PER_PERSON + DAMP_PER_PERSON * 2500 / 3.6), 2) AS SENSIBLE_HEAT_FRACTION,
        1.0 - DM.DIST_AIR AS FRACTION_RADIANT,
        O.MIN_REQUIRE_FRESH_AIR AS MIN_FRESH_AIR
        FROM OCCUPANT_GAINS O
        LEFT JOIN ROOM R
        ON O.OF_ROOM = R.ID
        LEFT JOIN SCHEDULE_YEAR S
        ON O.SCHEDULE = S.SCHEDULE_ID
        LEFT JOIN DIST_MODE DM
        ON O.DIST_MODE = DM.DIST_MODE_ID
        "
    )
    # assert_unique_name(people$NAME, "people")
    data.table::setDT(people)

    # NOTE: In DeST, the actual people number is calculated via:
    # min_val + sch_val * (max_val - min_val)
    #
    # If min_val is set to zero, then this is the same case as in EnergyPlus.
    # Otherwise, we have to set the people number to 1 and use the calculated
    # values and create new people number schedule based on it.
    non_zero_min <- DBI::dbGetQuery(
        dest,
        "
        SELECT GAIN_ID, SCHEDULE, MAXNUMBER, MINNUMBER
        FROM OCCUPANT_GAINS
        WHERE MINNUMBER != 0
        "
    )
    if (nrow(non_zero_min) > 0L) {
        # extract the schedule values
        sch <- DBI::dbGetQuery(
            dest,
            sprintf(
                "SELECT SCHEDULE_ID, NAME, DATA FROM SCHEDULE_YEAR WHERE SCHEDULE_ID IN (%s)",
                paste(unique(non_zero_min$SCHEDULE), collapse = ", ")
            )
        )
        data.table::setDT(sch)
        data.table::set(
            sch,
            NULL,
            "DATA",
            lapply(sch$DATA, readBin, what = "double", n = 7890L)
        )

        # create new schedule based on the calculated values
        data.table::setDT(non_zero_min)
        non_zero_min[
            sch,
            on = c("SCHEDULE" = "SCHEDULE_ID"),
            data := Map(
                function(min, max, sch) {
                    min + sch * (max - min)
                },
                MINNUMBER,
                MAXNUMBER,
                i.DATA
            )
        ]
    }

    # NOTE: In EnergyPlus, the people activity level can be changed via
    # schedules. However, in DeST, it is a fixed value. So here we have to
    # create a schedule with constant value for each people object.
    out_activity <- destep_add(
        dest, ep,
        # TODO: make sure to handle the case when the schedule already exists
        "ScheduleTypeLimits" = list("Any Number"),
        "Schedule:Constant" := list(
            sprintf("People Act Level of %s", activity_levels),
            "Any Number",
            activity_levels
        )
    )

    # NOTE: As the 2nd field in the 'People' class has been changed after the
    # 'Space' concept was introduced, we ignore the field names when inserting
    # to make sure it works across multiple EnergyPlus versions.
    #
    # Also, in order to take advantage of the 'NA' values in 'Number of People'
    # and 'People per Floor Area', we use 'Idf$load()' instead of 'Idf$add()'.
    out_people <- destep_load(
        destp,
        ep,
        eplusr::dt_to_load(people[, list(
            id = ID,
            class = "People",
            # 01: Name
            NAME,
            # 02: Zone or ZoneList or Space or SpaceList Name
            ROOM_NAME,
            # 03: Number of People Schedule Name
            SCHEDULE_NAME,
            # 04: Number of People Calculation Method
            METHOD,
            # 05: Number of People
            MAX_NUMBER_OF_PEOPLE,
            # 06: People per Floor Area
            MAX_PEOPLE_PER_AREA,
            # 07: Floor Area per Person
            NA_real_,
            # 08: Fraction Radiant
            FRACTION_RADIANT,
            # 09: Sensible Heat Fraction
            SENSIBLE_HEAT_FRACTION,
            # 10: Activity Level Schedule Name
            ACTIVITY_LEVEL = sprintf("People Act Level of %s", HEAT_PER_PERSON)
        )])
    )
    data.table::set(
        out_people$object,
        NULL,
        "rleid",
        out_people$object$rleid + nrow(out_activity$object)
    )
    data.table::set(
        out_people$value,
        NULL,
        "rleid",
        out_people$value$rleid + nrow(out_activity$object)
    )

    out <- list(
        object = data.table::rbindlist(list(
            out_people$object,
            out_activity$object
        )),
        value = data.table::rbindlist(list(
            out_people$value,
            out_activity$value
        ))
    )

    # always attach the table to the output in case it is useful later
    attr(out, "table") <- people

    out
}
